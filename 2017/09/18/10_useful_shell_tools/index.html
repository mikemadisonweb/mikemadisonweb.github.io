<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 10 useful shell tools to boost web developer workflow · todo(): redo · Mikhail Bakulin's blog</title><meta name="description" content="The most useful commands for a software engineer, based on my experience"><meta name="keywords" content="unix shell bash zsh head tail sed gnomon grep jq make awk curl oh-my-zsh"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon_tree.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://mikemadisonweb.github.io/atom.xml" title="todo(): redo · Mikhail Bakulin's blog"><!-- Global Site Tag (gtag.js) - Google Analytics--><script async src="https://www.googletagmanager.com/gtag/js?id=UA-106650807-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments)};
gtag('js', new Date());
gtag('config', 'UA-106650807-1');</script></head><body><div class="fixed-width"><header><a href="/" class="logo-link"><img src="/favicon_tree.png" alt="logo"><h1 class="logo-text"><span class="logo-slashes">// todo():</span><span>redo</span></h1></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/cv/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header></div><main class="container"><div class="post-img-container"><img src="https://mikemadisonweb.github.io/2017/09/18/10_useful_shell_tools/10_useful_shell_tools.jpg" class="post-img"></div><div class="fixed-width"><div class="post"><article class="post-block"><h1 class="post-title"><span class="pre-title">//&nbsp;todo():&nbsp;</span>10 useful shell tools to boost web developer workflow</h1><div class="post-tags"><a href="/tags/Unix/" class="post-tag">Unix</a><a href="/tags/Shell/" class="post-tag">Shell</a><a href="/tags/Bash/" class="post-tag">Bash</a></div><div class="post-date">Sep 18, 2017</div><div class="post-content"><p>Tips and tricks presented in this article are not essential to build a web application, but when you do stuff in a command line environment in your day to day work it can boost your productivity drastically.<br><a id="more"></a><br>All tools presented here are small utilities that are just making your life easier, none of these can be considered a lifesaver software. However little things that can become a big deal for you in a long run. I will add examples to each part, but I can’t guarantee the correctness of syntax between all Linux distributions and MacOS, as it can vary slightly. If you want to use these on Windows I can recommend you to use a terminal emulator, like <a href="http://babun.github.io/" target="_blank" rel="noopener">Babun</a>. Certain keywords like <code>filename</code> and <code>command</code> will be used as placeholders to actual filename.</p>
<h2 id="1-head-amp-tail"><a href="#1-head-amp-tail" class="headerlink" title="1: head &amp; tail"></a>1: head &amp; tail</h2><p>Most of you are probably familiar with <code>head</code> and <code>tail</code> commands, but not everyone knows that they can do more than just to print first and last parts of files respectfully. Using simple shell magic we can, for example, truncate a file to the number of lines from the beginning:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 100 filename | tee filename</span><br></pre></td></tr></table></figure></p>
<p>To append these lines to the end of a file instead:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 100 filename &gt;&gt; filename</span><br></pre></td></tr></table></figure></p>
<p>Next one is more practical, as you can monitor your logs in real-time:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -F filename</span><br></pre></td></tr></table></figure></p>
<p>Beware that options <code>-f</code> and <code>-F</code> in tail command is very similar, but have one significant distinction. The <code>-F</code> option will keep track of changes based on the filename and not the inode number, that could change during log rotation.</p>
<h2 id="2-sed"><a href="#2-sed" class="headerlink" title="2: sed"></a>2: sed</h2><p>One of the tools that can be really handy when you need to apply certain manipulations on a text file. Search and replace based on regular expressions can be done relatively fast and easy even if the file is too big to open it in a text editor. To replace all occurrences of a string in a file, overwriting the file you can run the following command:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/find/replace/g'</span> filename</span><br></pre></td></tr></table></figure></p>
<p>However, that is not all you can do with it. If you only need to count lines in a file:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'$='</span> filename</span><br></pre></td></tr></table></figure></p>
<p>As I said <code>tail</code> and <code>head</code> commands can give you some portion of data from the end or the beginning of the file, but what if I need something in the middle. Let’s suppose that I know exact line numbers on which needed text resides:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'55,60p'</span> filename</span><br></pre></td></tr></table></figure></p>
<p>It will print all the contents between 55th and 60th lines.<br>Same in-place truncation that’s can be done with <code>head</code>(first one in this article), can be easily done with <code>sed</code> as well:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'101,$ d'</span> filename</span><br></pre></td></tr></table></figure></p>
<p>It would delete all lines in a file starting from 101.</p>
<h2 id="3-gnomon"><a href="#3-gnomon" class="headerlink" title="3: gnomon"></a>3: gnomon</h2><p>The next one is not a built-in Linux utility and it is written in Javascript by Paypal. It prepends standard output with timestamp information, so you can profile execution time of your scripts. This is how I benchmark query execution in MongoDB that is located in Docker container:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -i mongo mongo dbname --quiet &lt; benchmark | gnomon</span><br></pre></td></tr></table></figure></p>
<p>By piping scripts to gnomon, you will get each line time elapsed from the previous line or the beginning of script execution, based on passed options.</p>
<p>You can install it globally using npm or yarn:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add gnomon</span><br></pre></td></tr></table></figure></p>
<h2 id="4-grep"><a href="#4-grep" class="headerlink" title="4: grep"></a>4: grep</h2><p>Most of you are probably already familiar with <code>grep</code>, but talking about stuff you can do with pipes, I can’t leave this one unmentioned. By all means <code>grep</code> can be used without a pipe, but that is where it really shines for a web developer:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -i | grep <span class="string">'pgsql'</span></span><br></pre></td></tr></table></figure></p>
<p>That way you can filter any command output using patterns or regular expressions. In addition to that, you can use <code>-n</code> option to show line numbers for each match, <code>-c</code> to print count of matches instead and a bunch of others.</p>
<h2 id="5-jq"><a href="#5-jq" class="headerlink" title="5: jq"></a>5: jq</h2><p>As you probably used to deal with JSON a lot, jq is a small sed-like tool that can save you a lot of time. Let’s say you receive some JSON-data from a remote application and you want to pretty-print it to make it more readable. Then just pipe it to jq with <code>.</code> as a filter:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'&#123;"result":&#123; "some":&#123;"random":"data"&#125;&#125;&#125;'</span> | jq .</span><br></pre></td></tr></table></figure></p>
<p>Here I just simulated remote call with <code>echo</code>, the result output would be:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"result"</span>: &#123;</span><br><span class="line">    <span class="string">"some"</span>: &#123;</span><br><span class="line">      <span class="string">"random"</span>: <span class="string">"data"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The output can be filtered further like this:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'&#123;"result":&#123; "some":&#123;"random":"data"&#125;&#125;&#125;'</span> | jq .result.some.random</span><br></pre></td></tr></table></figure></p>
<p>It will print <code>&quot;data&quot;</code>, could it be easier than that? In a JSON cumbersome mess jq can be your guide.</p>
<h2 id="6-make"><a href="#6-make" class="headerlink" title="6: make"></a>6: make</h2><p>Let’s look at <code>make</code> utility from an unusual point of view. We all know it as dependency-tracking build utility, but it can be used as a task runner. The main benefit of it is that <code>make</code> is available on every Unix-like system, no installation is needed and you can put Makefile with a bunch of project related tasks in your repository and do not worry about another developer would not be able to run it. But why even bother with task runners in the first place? Some shell commands are useful but it’s painful to remember them as they are long and hard to remember. The most common solution is to make an alias in your system to make that command easier to remember and faster to type. But every project might have its own set of handy commands, so it is not a good idea to keep it in one place and it can be advantageous to share these with other developers. This is an example of Makefile contents made for my Go project:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">unit_test:</span></span><br><span class="line">    @<span class="variable">$(<span class="built_in">call</span> PRINT_INFO, "Run unit-tests")</span></span><br><span class="line">    @go test -v $<span class="variable">$(go list ./app/... | grep -v excluded_dir)</span></span><br><span class="line"></span><br><span class="line"><span class="section">fmt:</span></span><br><span class="line">    @<span class="variable">$(<span class="built_in">call</span> PRINT_INFO, "Format")</span></span><br><span class="line">    @go fmt $<span class="variable">$(go list ./app/... | grep -v excluded_dir)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> PRINT_INFO</span><br><span class="line">    echo -e <span class="string">"\033[1;48;5;33m$1 \033[0m"</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure></p>
<p>Parameters and environment variables can be used in Makefile as well, but be advised that make is using its own syntax that is different from Bash and it accepts only tabs as indentation.</p>
<h2 id="7-awk"><a href="#7-awk" class="headerlink" title="7: awk"></a>7: awk</h2><p>To work with text more like rows and columns, rather than patterns, I will recommend using <code>awk</code> over <code>sed</code>. It can be really convenient for file formats, like csv and tsv. For example, if you want to sum the values in the second column of a file and print the total:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;s+=$2&#125; END &#123;print s&#125;'</span> filename</span><br></pre></td></tr></table></figure></p>
<p>To use comma as a field separator instead of space <code>-F</code> option can be used. This is how can you print contents of a file without any duplicate rows:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'!($0 in array) &#123; array[$0]; print &#125;'</span> filename</span><br></pre></td></tr></table></figure></p>
<p>Despite the fact that it can be done more elegant with <code>uniq</code>, I think you got the point. With <code>awk</code> you can write your own mini-scripts to apply on a text file.</p>
<h2 id="8-curl"><a href="#8-curl" class="headerlink" title="8: curl"></a>8: curl</h2><p>I advocate using <code>curl</code> whenever data needs to be sent or received in a command-line environment. But let’s start with a fun part. There is a fast way to figure out your IP address, just type one of those:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl wtfismyip.com/text</span><br><span class="line">curl wgetip.com</span><br><span class="line">curl ifcfg.me</span><br><span class="line">curl eth0.me</span><br></pre></td></tr></table></figure></p>
<p>There is basically no need to click anything to do that. Moreover, you can get the weather forecast:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl wttr.in</span><br></pre></td></tr></table></figure></p>
<p><img src="curl_weather.png" alt="curl weather forecast"><br>Back to work, if you need to debug some particular request and you are using Google Chrome, head on to DevTools, choose Network tab, find a request of interest and right-click on it. In the popup menu under the ‘Copy’ group, there is a ‘Copy as cURL’. That’s awesome! Now you can paste it into Terminal, debug and change it as you wish.</p>
<h2 id="9-bg-amp-fg"><a href="#9-bg-amp-fg" class="headerlink" title="9: bg &amp; fg"></a>9: bg &amp; fg</h2><p>Any process that was executed from shell can be rather run in the foreground, that means that it blocks a terminal window, no new processes can not run until that initial one stops or in the background, that can be considered as an asynchronous way. There is nothing too advanced about these features, but it worth noting that any process that was started in foreground can be suspended using <code>ctrl+z</code> keyboard shortcut, monitored using <code>jobs</code> command, resumed by <code>fg</code>, sent to background using <code>bg</code> or stopped by <code>kill %n</code> command where n is a number of a job.<br>To run a process in the background, to begin with, just append an ampersand (&amp;) to the command:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &amp;</span><br></pre></td></tr></table></figure></p>
<h2 id="10-Bash-alternatives"><a href="#10-Bash-alternatives" class="headerlink" title="10: Bash alternatives"></a>10: Bash alternatives</h2><p>It is important to personalize your working environment the way that suits you. So it can be beneficial to experiment a bit with various programs and frameworks. My personal preference is Z shell over Bash, as it has all advantages of Bash with several additional features. There is a decent overview of Zsh in a <a href="https://www.slideshare.net/jaguardesignstudio/why-zsh-is-cooler-than-your-shell-16194692" target="_blank" rel="noopener">presentation</a> by Brendon Rapp that is worth looking. If you are curious, there is a whole lot of <a href="https://github.com/alebcay/awesome-shell" target="_blank" rel="noopener">awesome stuff</a> you can discover that will enhance your user experience. </p>
<p>I can recommend <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">Oh-my-zsh</a> for styling, <a href="https://github.com/rupa/z" target="_blank" rel="noopener">Z script</a> for easy navigation and <a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">Fish syntax highlighting</a> to make commands look clearer:<br><img src="fish_syntax_highlighting.png" alt="Fish shell like syntax highlighting"></p>
</div><p class="ending"><i>That's all for today. Happy coding!</i></p></article></div></div></main><div class="fixed-width"><footer><div class="paginator"><a href="/2018/03/06/go-autoreload/" class="prev">PREV</a><a href="/2017/05/04/tldr-series-rabbitmq/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'mikemadison';
var disqus_identifier = '2017/09/18/10_useful_shell_tools/';
var disqus_title = '10 useful shell tools to boost web developer workflow';
var disqus_url = 'https://mikemadisonweb.github.io/2017/09/18/10_useful_shell_tools/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//mikemadison.disqus.com/count.js" async></script><div class="copyright"><p><a href="/atom.xml"><img src="/images/rss_ico.png" class="rss-icon"><span> Feed |</span></a><a href="/sitemap.xml"><span> Sitemap |</span></a><span> © 2016 - 2020 <a href="https://mikemadisonweb.github.io">Mikhail Bakulin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</span></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>